/*
 * This file is part of the Micro Python project, http://micropython.org/
 * This file was generated by micropython-extmod-generator https://github.com/prusnak/micropython-extmod-generator
 * from Python stab file quad.py
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2020 Ihor Nehrutsa
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
ESP32 Quadrature Encoder based on Pulse Counter(PCNT)
Based on 
https://github.com/madhephaestus/ESP32Encoder
https://github.com/bboser/MicroPython_ESP32_psRAM_LoBo/blob/quad_decoder/MicroPython_BUILD/components/micropython/esp32/machine_dec.c
See also
https://github.com/espressif/esp-idf/tree/master/examples/peripherals/pcnt/rotary_encoder
*/

#define MODULE_QUAD_ENABLED (1) // you may relocate this line to the mpconfigport.h
#if MODULE_QUAD_ENABLED

// Include required definitions first
#include "py/obj.h"
//#include <stdio.h>

#include "driver/pcnt.h"
#include "esp_err.h"

#include "py/nlr.h"
#include "py/runtime.h"
//#include "modmachine.h"
//#include "mphalport.h"

#include "ESP32Encoder.h"
#include "../esp_err/esp_error.h"
//#include "quad_QUAD.h"


//---------------------------------------
static int machine_pin_get_gpio(mp_obj_t pin_in)
{
    if (MP_OBJ_IS_INT(pin_in)) {
        int wanted_pin = mp_obj_get_int(pin_in);
        if (!GPIO_IS_VALID_GPIO(wanted_pin)) {
            mp_raise_ValueError(MP_ERROR_TEXT("ESP PCNT invalid pin number"));
        }
        return wanted_pin;
    }
    return machine_pin_get_id(pin_in);
}

//extern const mp_obj_type_t esp_err_EspError_type;

//raise esp_err.EspError(esp_err.EspError.ESP_ERR_INVALID_ARG, '0x%X - ESP_ERR_INVALID_ARG' % esp_err.EspError.ESP_ERR_INVALID_ARG)

//#define raise_esp_error(err) mp_raise_msg_varg(&esp_err_EspError_type, MP_ERROR_TEXT("%d(0x%X) - "#err), err, err);
//#define raise_esp_error(err, ...) mp_raise_msg_varg(&esp_err_EspError_type, MP_ERROR_TEXT("%d(0x%X) - "#err), err, err, __VA_ARGS__);
/*       
static void raise_esp_error(esp_err_t err)
{
    mp_raise_msg_varg(&esp_err_EspError_type, MP_ERROR_TEXT("ESP32 error %d(0x%X)"), err, err);
}
*/

typedef struct _quad_QUAD_obj_t {
    mp_obj_base_t base;
    //pcnt_config_t unit_a;
    //pcnt_config_t unit_b;

//    void attach(int aPinNumber, int bPinNumber, enum encType et);
    bool attached; // =false;

//  static  pcnt_isr_handle_t user_isr_handle; //user's ISR service handle
//    bool direction;
//    bool working;

//    static bool attachedInterrupt;
//  int64_t getCountRaw();

//  void attachHalfQuad(int aPinNumber, int bPinNumber);
//  void attachFullQuad(int aPinNumber, int bPinNumber);
//  void attachSingleEdge(int aPinNumber, int bPinNumber);
//  int64_t getCount();
//  int64_t clearCount();
//  int64_t pauseCount();
//  int64_t resumeCount();

//  boolean isAttached(){return attached;}
//  void setCount(int64_t value);
//  static ESP32Encoder *encoders[MAX_ESP32_ENCODERS];
    gpio_num_t aPinNumber;
    gpio_num_t bPinNumber;
    pcnt_unit_t unit;
    bool fullQuad; // = false;
//    int countsMode; // = 2;
    volatile int64_t count; // = 0;
    pcnt_config_t r_enc_config;
    enum puType useInternalWeakPullResistors;
} quad_QUAD_obj_t;

static quad_QUAD_obj_t *encoders[MAX_ESP32_ENCODERS] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

static bool attachedInterrupt=false;
static pcnt_isr_handle_t user_isr_handle = NULL;

STATIC const mp_obj_type_t quad_QUAD_type;

//***********************************
/* Decode what PCNT's unit originated an interrupt
 * and pass this information together with the event type
 * the main program using a queue.
 */
static void IRAM_ATTR pcnt_intr_handler(void *arg) {
    quad_QUAD_obj_t *ptr;

    uint32_t intr_status = PCNT.int_st.val;
    int i;

    for (i = 0; i < PCNT_UNIT_MAX; i++) {
        if (intr_status & (1 << i)) {
            ptr = encoders[i];
            /* Save the PCNT event type that caused an interrupt
             to pass it to the main program */

            int64_t status=0;
            if (PCNT.status_unit[i].h_lim_lat) {
                status = ptr->r_enc_config.counter_h_lim;
            }
            if (PCNT.status_unit[i].l_lim_lat) {
                status = ptr->r_enc_config.counter_l_lim;
            }
            //pcnt_counter_clear(ptr->unit);
            PCNT.int_clr.val |= 1 << i; // clear the interrupt
            ptr->count = status + ptr->count;

            break;
        }
    }
}

//-------------------------------------------------------------------------------------------------------------
static void attach(quad_QUAD_obj_t *self, int a, gpio_num_t b, enum encType et)
{
    /*
    if (self->attached) {
        mp_raise_msg(&mp_type_Exception, MP_ERROR_TEXT("Already attached, FAIL!"));
        return;
    }
    */
    int index = 0;
    for (; index < MAX_ESP32_ENCODERS; index++) {
        if (encoders[index] == NULL) {
            break;
        }
    }
    if (index == MAX_ESP32_ENCODERS) {
        mp_raise_msg(&mp_type_Exception, MP_ERROR_TEXT("Too many encoders, FAIL!"));
        return;
    }

    // Set data now that pin attach checks are done
    self->fullQuad = et != SINGLE;
    self->unit = (pcnt_unit_t) index;
    self->aPinNumber = (gpio_num_t) a;
    self->bPinNumber = (gpio_num_t) b;

    //Set up the IO state of hte pin
    gpio_pad_select_gpio(self->aPinNumber);
    gpio_pad_select_gpio(self->bPinNumber);
    gpio_set_direction(self->aPinNumber, GPIO_MODE_INPUT);
    gpio_set_direction(self->bPinNumber, GPIO_MODE_INPUT);
    if(self->useInternalWeakPullResistors==DOWN){
        gpio_pulldown_en(self->aPinNumber);
        gpio_pulldown_en(self->bPinNumber);
    }
    if(self->useInternalWeakPullResistors==UP){
        gpio_pullup_en(self->aPinNumber);
        gpio_pullup_en(self->bPinNumber);
    }
    // Set up encoder PCNT configuration
    self->r_enc_config.pulse_gpio_num = self->aPinNumber; //Rotary Encoder Chan A
    self->r_enc_config.ctrl_gpio_num = self->bPinNumber;    //Rotary Encoder Chan B

    self->r_enc_config.unit = self->unit;
    self->r_enc_config.channel = PCNT_CHANNEL_0;

    self->r_enc_config.pos_mode = self->fullQuad ? PCNT_COUNT_DEC : PCNT_COUNT_DIS; //Count Only On Rising-Edges
    self->r_enc_config.neg_mode = PCNT_COUNT_INC;   // Discard Falling-Edge

    self->r_enc_config.lctrl_mode = PCNT_MODE_KEEP;    // Rising A on HIGH B = CW Step
    self->r_enc_config.hctrl_mode = PCNT_MODE_REVERSE; // Rising A on LOW B = CCW Step

    self->r_enc_config.counter_h_lim = _INT16_MAX;
    self->r_enc_config.counter_l_lim = _INT16_MIN ;

    esp_err_t err;
    err = pcnt_unit_config(&self->r_enc_config);
    if (err != ESP_OK)
        raise_esp_error(err);

    if (et == FULL) {
        // set up second channel for full quad
        self->r_enc_config.pulse_gpio_num = self->bPinNumber; //make prior control into signal
        self->r_enc_config.ctrl_gpio_num = self->aPinNumber;    //and prior signal into control

        self->r_enc_config.unit = self->unit;
        self->r_enc_config.channel = PCNT_CHANNEL_1; // channel 1

        self->r_enc_config.pos_mode = PCNT_COUNT_DEC; //Count Only On Rising-Edges
        self->r_enc_config.neg_mode = PCNT_COUNT_INC;   // Discard Falling-Edge

        self->r_enc_config.lctrl_mode = PCNT_MODE_REVERSE;    // prior high mode is now low
        self->r_enc_config.hctrl_mode = PCNT_MODE_KEEP; // prior low mode is now high

        self->r_enc_config.counter_h_lim = _INT16_MAX;
        self->r_enc_config.counter_l_lim = _INT16_MIN ;

        err = pcnt_unit_config(&self->r_enc_config);
        if (err != ESP_OK)
            raise_esp_error(err);
    } else { // make sure channel 1 is not set when not full quad
        self->r_enc_config.pulse_gpio_num = self->bPinNumber; //make prior control into signal
        self->r_enc_config.ctrl_gpio_num = self->aPinNumber;    //and prior signal into control

        self->r_enc_config.unit = self->unit;
        self->r_enc_config.channel = PCNT_CHANNEL_1; // channel 1

        self->r_enc_config.pos_mode = PCNT_COUNT_DIS; //disabling channel 1
        self->r_enc_config.neg_mode = PCNT_COUNT_DIS;   // disabling channel 1

        self->r_enc_config.lctrl_mode = PCNT_MODE_DISABLE;    // disabling channel 1
        self->r_enc_config.hctrl_mode = PCNT_MODE_DISABLE; // disabling channel 1

        self->r_enc_config.counter_h_lim = _INT16_MAX;
        self->r_enc_config.counter_l_lim = _INT16_MIN ;

        err = pcnt_unit_config(&self->r_enc_config);
        if (err != ESP_OK)
            raise_esp_error(err);
    }

    // Filter out bounces and noise
    err = pcnt_set_filter_value(self->unit, 250);  // Filter Runt Pulses
        if (err != ESP_OK)
            raise_esp_error(err);
    err = pcnt_filter_enable(self->unit);
        if (err != ESP_OK)
            raise_esp_error(err);

    /* Enable events on maximum and minimum limit values */
    err = pcnt_event_enable(self->unit, PCNT_EVT_H_LIM);
        if (err != ESP_OK)
            raise_esp_error(err);
    err = pcnt_event_enable(self->unit, PCNT_EVT_L_LIM);
        if (err != ESP_OK)
            raise_esp_error(err);

    err = pcnt_counter_pause(self->unit); // Initial PCNT init
        if (err != ESP_OK)
            raise_esp_error(err);
    err = pcnt_counter_clear(self->unit);
        if (err != ESP_OK)
            raise_esp_error(err);
    self->count = 0;
    /* Register ISR handler and enable interrupts for PCNT unit */
    if(attachedInterrupt==false){
        attachedInterrupt=true;
        err = pcnt_isr_register(pcnt_intr_handler,(void *) NULL, (int)0, (pcnt_isr_handle_t *)&user_isr_handle);
        if (err != ESP_OK){
            mp_raise_msg(&mp_type_Exception, MP_ERROR_TEXT("Encoder wrap interrupt failed"));
        }
    }
    err = pcnt_intr_enable(self->unit);
        if (err != ESP_OK)
            raise_esp_error(err);
    err = pcnt_counter_resume(self->unit);
        if (err != ESP_OK)
            raise_esp_error(err);

    encoders[index] = self;
    self->attached = true;
}

//-------------------------------------------------------------------------------------------------------------
// Defining QUAD methods
// def QUAD.__init__(encoder_type: EncoderType, aPinNumber: int, bPinNumber: int=-1, pin_pull_type: PinPullType=1)
STATIC mp_obj_t quad_QUAD_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args)
{
    mp_arg_check_num(n_args, n_kw, 2, 4, true);
    int encoder_type = mp_obj_get_int(args[0]);
    gpio_num_t pin_a = machine_pin_get_gpio(args[1]);
    gpio_num_t pin_b = PCNT_PIN_NOT_USED;
    if (n_args + n_kw >= 3)
        pin_b = machine_pin_get_gpio(args[2]);
/*
    if (unit < 0 || unit > PCNT_UNIT_MAX)
        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "ESP PCNT bad timer number %d", unit));
*/
    // create QUAD object for the given unit
    quad_QUAD_obj_t *self = m_new_obj(quad_QUAD_obj_t);
    self->base.type = &quad_QUAD_type;
    
	self->attached = false;
	self->aPinNumber = PCNT_PIN_NOT_USED; //(gpio_num_t) 0;
	self->bPinNumber = PCNT_PIN_NOT_USED; //(gpio_num_t) 0;
//  self->working = false;
//	self->direction = false;
    self->useInternalWeakPullResistors = DOWN;
//  mp_printf(MP_PYTHON_PRINTER, MP_ERROR_TEXT("pin_pull_type=%u %u "), self->useInternalWeakPullResistors, n_args);
    mp_printf(MP_PYTHON_PRINTER, "pin_pull_type=%u n_args=%d n_kw=%d ", self->useInternalWeakPullResistors, n_args, n_kw);
    if (n_args + n_kw >= 4)
        self->useInternalWeakPullResistors = mp_obj_get_int(args[3]);
//  mp_printf(MP_PYTHON_PRINTER, MP_ERROR_TEXT("_pin_pull_type=%u "), self->useInternalWeakPullResistors);
    mp_printf(MP_PYTHON_PRINTER, "_pin_pull_type=%u \n", self->useInternalWeakPullResistors);
	self->unit = (pcnt_unit_t) -1;

#if 1
    attach(self, pin_a, pin_b, encoder_type);
#else
    // configure timer channel 0
    self->unit_a.channel = PCNT_CHANNEL_0;
    self->unit_a.pulse_gpio_num = pin_a;    // reverse from channel 1
    self->unit_a.ctrl_gpio_num = pin_b;
    self->unit_a.unit = unit;
    self->unit_a.pos_mode = PCNT_COUNT_DEC;
    self->unit_a.neg_mode = PCNT_COUNT_INC;
    self->unit_a.lctrl_mode = PCNT_MODE_KEEP;
    self->unit_a.hctrl_mode = PCNT_MODE_REVERSE;
    self->unit_a.counter_h_lim =  INT16_MAX;    // don't care if interrupt is not used?
    self->unit_a.counter_l_lim = -INT16_MAX;

    // configure timer channel 1
    self->unit_b.channel = PCNT_CHANNEL_1;
    self->unit_b.pulse_gpio_num = pin_b;    // reverse from channel 0
    self->unit_b.ctrl_gpio_num = pin_a;
    self->unit_b.unit = unit;
    self->unit_b.pos_mode = PCNT_COUNT_DEC;
    self->unit_b.neg_mode = PCNT_COUNT_INC;
    self->unit_b.lctrl_mode = PCNT_MODE_REVERSE;
    self->unit_b.hctrl_mode = PCNT_MODE_KEEP;
    self->unit_b.counter_h_lim =  INT16_MAX;    // don't care if interrupt is not used?
    self->unit_b.counter_l_lim = -INT16_MAX;

    if (n_args == 2) {
        // not sure if all this is required, but I've played long enough
        self->unit_a.pos_mode = PCNT_COUNT_INC;
        self->unit_a.hctrl_mode = PCNT_MODE_KEEP;

        self->unit_b.channel = PCNT_CHANNEL_1;
        self->unit_b.ctrl_gpio_num = pin_b;
        self->unit_b.pos_mode = PCNT_COUNT_DIS;
        self->unit_b.neg_mode = PCNT_COUNT_DIS;
        self->unit_b.hctrl_mode = PCNT_MODE_KEEP;
    }

    pcnt_unit_config(&(self->unit_a));
    pcnt_unit_config(&(self->unit_b));

#if 1
    pcnt_filter_disable(unit);

    // init / start the counter
    pcnt_counter_pause(unit);
    pcnt_counter_clear(unit);
    pcnt_counter_resume(unit);
#else
    // Filter out bounces and noise
    pcnt_set_filter_value(unit, 250);  // Filter Runt Pulses
    pcnt_filter_enable(unit);


    /* Enable events on maximum and minimum limit values */
    pcnt_event_enable(unit, PCNT_EVT_H_LIM);
    pcnt_event_enable(unit, PCNT_EVT_L_LIM);

    pcnt_counter_pause(unit); // Initial PCNT init
    /* Register ISR handler and enable interrupts for PCNT unit */
    if(attachedInterrupt == false){
        attachedInterrupt = true;
        esp_err_t er = pcnt_isr_register(pcnt_intr_handler,(void *) NULL, (int)0,
                (pcnt_isr_handle_t *)&user_isr_handle);
        if (er != ESP_OK){
            mp_raise_msg(&mp_type_Exception, MP_ERROR_TEXT("ESP PCNT encoder interrupt registration failed"));
        }
    }
    pcnt_intr_enable(unit);
    pcnt_counter_clear(unit);
    pcnt_counter_resume(unit);
#endif

#endif

    // not sure what this is for or if it's needed
    mp_map_t kw_args;
    mp_map_init_fixed_table(&kw_args, n_kw, args + n_args);

    return MP_OBJ_FROM_PTR(self);
}

//------------------------------------------------------------------------------------------
STATIC void quad_QUAD_print(const mp_print_t *print, mp_obj_t self_obj, mp_print_kind_t kind)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);

    mp_printf(print, "QUAD(unit=%u, Pin(%u)", self->unit, self->aPinNumber);
    if (self->bPinNumber != PCNT_PIN_NOT_USED)
       mp_printf(print, ", Pin(%u)", self->bPinNumber);
    mp_printf(print, ", pin_pull_type=%u)", self->useInternalWeakPullResistors);
}

//-----------------------------------------------------------------
STATIC mp_obj_t quad_QUAD_set_count(mp_obj_t self_obj, mp_obj_t value_obj)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);
    int64_t value = mp_obj_get_int(value_obj);

    int16_t count;
    esp_err_t err = pcnt_get_counter_value(self->unit, &count);
    if (err != ESP_OK)
       raise_esp_error(err);
    self->count = value - count;

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(quad_QUAD_set_count_obj, quad_QUAD_set_count);

//-----------------------------------------------------------------
STATIC mp_obj_t quad_QUAD_set_filter(mp_obj_t self_obj, mp_obj_t enable_obj, mp_obj_t value_obj)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);
    bool enable = mp_obj_is_true(enable_obj);
    mp_int_t value = mp_obj_get_int(value_obj);

    esp_err_t err;
    if (enable) {
        err = pcnt_set_filter_value(self->unit, value);  // Filter Runt Pulses
        if (err != ESP_OK)
            raise_esp_error(err);
        err = pcnt_filter_enable(self->unit);
        if (err != ESP_OK)
            raise_esp_error(err);
    } else
        err = pcnt_filter_disable(self->unit);
        if (err != ESP_OK)
            raise_esp_error(err);

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_3(quad_QUAD_set_filter_obj, quad_QUAD_set_filter);

//-----------------------------------------------------------------
STATIC mp_obj_t quad_QUAD_count_raw(mp_obj_t self_obj)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);

    int16_t count;
    pcnt_get_counter_value(self->unit, &count);  // without error test

    return MP_OBJ_NEW_SMALL_INT(count);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(quad_QUAD_count_raw_obj, quad_QUAD_count_raw);

//-----------------------------------------------------------------
STATIC mp_obj_t quad_QUAD_count(mp_obj_t self_obj)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);

    int16_t count;
    pcnt_get_counter_value(self->unit, &count);  // without error test

    return mp_obj_new_int_from_ll(self->count + count);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(quad_QUAD_count_obj, quad_QUAD_count);

//-----------------------------------------------------------------
STATIC mp_obj_t quad_QUAD_count_and_clear(mp_obj_t self_obj)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);

    int16_t count;
    esp_err_t err;
    err = pcnt_get_counter_value(self->unit, &count);
    if (err != ESP_OK)
       raise_esp_error(err);
    err = pcnt_counter_clear(self->unit);
    if (err != ESP_OK)
       raise_esp_error(err);
    int64_t _count = self->count + count;
    self->count = 0;
    return mp_obj_new_int_from_ll(_count);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(quad_QUAD_count_and_clear_obj, quad_QUAD_count_and_clear);

//-----------------------------------------------------------------
STATIC mp_obj_t quad_QUAD_clear(mp_obj_t self_obj)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);

    esp_err_t err = pcnt_counter_clear(self->unit);
    if (err != ESP_OK)
       raise_esp_error(err);
    self->count = 0;

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(quad_QUAD_clear_obj, quad_QUAD_clear);

//-----------------------------------------------------------------
STATIC mp_obj_t quad_QUAD_pause(mp_obj_t self_obj)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);

    esp_err_t err = pcnt_counter_pause(self->unit);
    if (err != ESP_OK)
       raise_esp_error(err);

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(quad_QUAD_pause_obj, quad_QUAD_pause);

//-----------------------------------------------------------------
STATIC mp_obj_t quad_QUAD_resume(mp_obj_t self_obj)
{
    quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(self_obj);

    esp_err_t err = pcnt_counter_resume(self->unit);
    if (err != ESP_OK)
       raise_esp_error(err);

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(quad_QUAD_resume_obj, quad_QUAD_resume);

//==============================================================
/*
// def QUAD.attach_full_quad(self, aPinNumber: int, bPinNumber: int, pin_pull_type: int=1)
STATIC mp_obj_t quad_QUAD_attach_full_quad(size_t n_args, const mp_obj_t *args) {
	quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(args[0]);
	mp_int_t aPinNumber = mp_obj_get_int(args[1]);
	mp_int_t bPinNumber = mp_obj_get_int(args[2]);
    mp_int_t pin_pull_type = DOWN;
    if (n_args == 4)
	    pin_pull_type = mp_obj_get_int(args[3]);

    attach(self, aPinNumber, bPinNumber, FULL);

	return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(quad_QUAD_attach_full_quad_obj, 3, 4, quad_QUAD_attach_full_quad);

// def QUAD.attach_half_quad(self, aPinNumber: int, bPinNumber: int, pin_pull_type: int=1)
STATIC mp_obj_t quad_QUAD_attach_half_quad(size_t n_args, const mp_obj_t *args) {
	quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(args[0]);
	mp_int_t aPinNumber = mp_obj_get_int(args[1]);
	mp_int_t bPinNumber = mp_obj_get_int(args[2]);
	mp_int_t pin_pull_type = DOWN;
    if (n_args == 4)
	    pin_pull_type = mp_obj_get_int(args[3]);

    attach(self, aPinNumber, bPinNumber, HALF);

	return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(quad_QUAD_attach_half_quad_obj, 3, 4, quad_QUAD_attach_half_quad);

// def QUAD.attach_single_edge(self, aPinNumber: int, bPinNumber: int, pin_pull_type: int=1)
STATIC mp_obj_t quad_QUAD_attach_single_edge(size_t n_args, const mp_obj_t *args) {
	quad_QUAD_obj_t *self = MP_OBJ_TO_PTR(args[0]);
	mp_int_t aPinNumber = mp_obj_get_int(args[1]);
	mp_int_t bPinNumber = mp_obj_get_int(args[2]);
	mp_int_t pin_pull_type = DOWN;
    if (n_args == 4)
	    pin_pull_type = mp_obj_get_int(args[3]);

    attach(self, aPinNumber, bPinNumber, SINGLE);

	return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(quad_QUAD_attach_single_edge_obj, 3, 4, quad_QUAD_attach_single_edge);
*/
// QUAD stuff
// Register class methods
STATIC const mp_rom_map_elem_t quad_QUAD_locals_dict_table[] = {
    /*
    { MP_ROM_QSTR(MP_QSTR_attach_single_edge), MP_ROM_PTR(&quad_QUAD_attach_single_edge_obj) },
    { MP_ROM_QSTR(MP_QSTR_attach_half_quad), MP_ROM_PTR(&quad_QUAD_attach_half_quad_obj) },
    { MP_ROM_QSTR(MP_QSTR_attach_full_quad), MP_ROM_PTR(&quad_QUAD_attach_full_quad_obj) },
    */
    { MP_ROM_QSTR(MP_QSTR_count_raw), MP_ROM_PTR(&quad_QUAD_count_raw_obj) },
    { MP_ROM_QSTR(MP_QSTR_count), MP_ROM_PTR(&quad_QUAD_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_count_and_clear), MP_ROM_PTR(&quad_QUAD_count_and_clear_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&quad_QUAD_clear_obj) },
    { MP_ROM_QSTR(MP_QSTR_pause), MP_ROM_PTR(&quad_QUAD_pause_obj) },
    { MP_ROM_QSTR(MP_QSTR_resume), MP_ROM_PTR(&quad_QUAD_resume_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_filter), MP_ROM_PTR(&quad_QUAD_set_filter_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_count), MP_ROM_PTR(&quad_QUAD_set_count_obj) },
};
STATIC MP_DEFINE_CONST_DICT(quad_QUAD_locals_dict, quad_QUAD_locals_dict_table);

// Create the class-object itself
STATIC const mp_obj_type_t quad_QUAD_type = {
    { &mp_type_type },
    .name = MP_QSTR_QUAD,
    .print = quad_QUAD_print,
    .make_new = quad_QUAD_make_new,
    .locals_dict = (mp_obj_dict_t*)&quad_QUAD_locals_dict,
};


// class EncoderType(object):
// enumaration
typedef struct _mp_obj_EncoderType_t {
    mp_obj_base_t base;
} mp_obj_EncoderType_t;

// EncoderType constants
// EncoderType stuff
STATIC const mp_rom_map_elem_t quad_EncoderType_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FULL), MP_ROM_INT(FULL) },
    { MP_ROM_QSTR(MP_QSTR_HALF), MP_ROM_INT(HALF) },
    { MP_ROM_QSTR(MP_QSTR_SINGLE), MP_ROM_INT(SINGLE) },
};
STATIC MP_DEFINE_CONST_DICT(quad_EncoderType_locals_dict, quad_EncoderType_locals_dict_table);

//STATIC const mp_obj_type_t quad_EncoderType_type = {
STATIC mp_obj_type_t quad_EncoderType_type = {
    { &mp_type_type },
    .name = MP_QSTR_EncoderType,
    .locals_dict = (void*)&quad_EncoderType_locals_dict,
};

// class PinPullType(object):
// enumaration
typedef struct _mp_obj_PinPullType_t {
    mp_obj_base_t base;
} mp_obj_PinPullType_t;

// PinPullType constants
// PinPullType stuff
STATIC const mp_rom_map_elem_t quad_PinPullType_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_INT(DOWN) },
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_INT(NONE) },
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_INT(UP) },
};
STATIC MP_DEFINE_CONST_DICT(quad_PinPullType_locals_dict, quad_PinPullType_locals_dict_table);

//STATIC const mp_obj_type_t quad_PinPullType_type = {
STATIC mp_obj_type_t quad_PinPullType_type = {
    { &mp_type_type },
    .name = MP_QSTR_PinPullType,
    .locals_dict = (void*)&quad_PinPullType_locals_dict,
};

// Set up the module properties
STATIC const mp_rom_map_elem_t quad_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_quad) },
    { MP_ROM_QSTR(MP_QSTR_QUAD), MP_ROM_PTR(&quad_QUAD_type) },
    { MP_ROM_QSTR(MP_QSTR_EncoderType), MP_ROM_PTR(&quad_EncoderType_type) },
    { MP_ROM_QSTR(MP_QSTR_PinPullType), MP_ROM_PTR(&quad_PinPullType_type) },
};
STATIC MP_DEFINE_CONST_DICT(quad_globals, quad_globals_table);

// Define the module object
const mp_obj_module_t quad_cmodule = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&quad_globals,
};
// Register the module
MP_REGISTER_MODULE(MP_QSTR_quad, quad_cmodule, MODULE_QUAD_ENABLED);

#endif // MODULE_QUAD_ENABLED
/*
// Set up the module properties
STATIC const mp_map_elem_t quad_globals_table[] = {
    { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_QUAD) },
    { MP_OBJ_NEW_QSTR(MP_QSTR_QUAD), (mp_obj_t)&quad_QUAD_type },
    { MP_ROM_QSTR(MP_QSTR_EncoderType), MP_ROM_PTR(&quad_EncoderType_type) },
    { MP_ROM_QSTR(MP_QSTR_PinPullType), MP_ROM_PTR(&quad_PinPullType_type) },
};
STATIC MP_DEFINE_CONST_DICT(quad_globals_dict, quad_globals_table);

// Define module object.
const mp_obj_module_t quad_cmodule = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&quad_globals_dict,
};

// Register the module to make it available in Python.
MP_REGISTER_MODULE(MP_QSTR_quad, quad_cmodule, MODULE_QUAD_ENABLED);
*/
